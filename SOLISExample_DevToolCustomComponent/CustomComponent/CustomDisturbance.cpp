// Automatically generated by Advanced Solutions Inc. MAXDevTool 2018c
// 
// ============================================================================
// 
// A custom file header for this custom project
// 
// ============================================================================
//     
#include "CustomDisturbance.hpp"

AUTOCODE_SOURCE_MACRO_CUSTOMDISTURBANCE

///////////////////////////////////////////////////////////////////////
// This is the constructor/destructor portion of the code.
///////////////////////////////////////////////////////////////////////
CCustomDisturbance::CCustomDisturbance(const char* InstanceName) :
   CComponentBase(InstanceName),
   m_Parm(*(m_Parm_ptr = new SCustomDisturbanceParm)), //#DevToolManaged
   m_Tlm(*(m_Tlm_ptr = new SCustomDisturbanceTlm)), //#DevToolManaged
   m_Connection(*(m_Connection_ptr = new SCustomDisturbanceConnection)), //#DevToolManaged
   m_Data(*(m_Data_ptr = new SCustomDisturbanceData)) //#DevToolManaged
{
   // This call takes care of known housekeeping tasks.
   AutogeneratedConstructor();
}

#ifdef INCLUDE_CCUSTOMDISTURBANCE_SECOND_CONSTRUCTOR
CCustomDisturbance::CCustomDisturbance(const char* InstanceName, SCustomDisturbanceParm& Parm, SCustomDisturbanceTlm& Tlm, SCustomDisturbanceConnection& Connection, SCustomDisturbanceData& Data) : // #DevToolSecondConstructor
   CComponentBase(InstanceName),
   m_Parm(Parm), //#DevToolManaged
   m_Parm_ptr(NULL), //#DevToolManaged
   m_Tlm(Tlm), //#DevToolManaged
   m_Tlm_ptr(NULL), //#DevToolManaged
   m_Connection(Connection), //#DevToolManaged
   m_Connection_ptr(NULL), //#DevToolManaged
   m_Data(Data), //#DevToolManaged
   m_Data_ptr(NULL) //#DevToolManaged
{
   // This call takes care of known housekeeping tasks.
   AutogeneratedConstructor();
}
#endif /* INCLUDE_CCUSTOMDISTURBANCE_SECOND_CONSTRUCTOR */

// The purpose of this function is to be called by either the primary or secondary constructor.
void CCustomDisturbance::CommonConstructor(void)
{

   // Uncomment these 'new' lines to allocate memory for member structures.
   // m_Data.MyStruct = new MyNamespace::MyStruct;
}

CCustomDisturbance::~CCustomDisturbance(void)
{
   // This call takes care of known housekeeping deallocation
   AutogeneratedDestructor();
}

///////////////////////////////////////////////////////////////////////
// This function is called with the creation of the factory, so if there
// is anything that you would like to do when the factory is created,
// here is where you can do it.  As it is now, a debug output is made so
// that you know your factory is being created within MCDH and your code
// is being executed.
///////////////////////////////////////////////////////////////////////

void CCustomDisturbance::UserCreateFactory(void)
{
   s_Factory->AddFactoryTags("Component");
}

///////////////////////////////////////////////////////////////////////
// This function handles initialization of the object
///////////////////////////////////////////////////////////////////////
void CCustomDisturbance::Init(void)
{
   // The autogenerated init function handles registration of any commands and/or telemetry
   // that may exist within this configurable component.
   AutogeneratedInit();

   // This callback to the parent component makes sure that any initialization that component
   // does also happens.
   CComponentBase::Init();
}

///////////////////////////////////////////////////////////////////////
// This function runs after all components have been initialized (each Init(void) has occured).
///////////////////////////////////////////////////////////////////////
void CCustomDisturbance::PostInit(void)
{
   // The autogenerated postinit function handles autogenerated postinit activites
   AutogeneratedPostInit();

   // This callback to the parent component makes sure that any post initialization that component
   // does also happens.  Manual uncommenting is required until the framework is completely ready
   CComponentBase::PostInit();
}

///////////////////////////////////////////////////////////////////////
// In the flight software, the three following methods that are called
// in each frame of execution.  The reason for multiple methods is so
// that each object can push data to hardware quickly at the start of
// the frame, interpret data from a previous frame and have an opportunity
// to take any computationally intensive steps once all the objects have
// had a chance to get their time critical work out of the way.
///////////////////////////////////////////////////////////////////////

// ProcessOutputs is the first function called in the frame.  It is for sending data
// to hardware and must be as fast as possible.  Note, ProcessOutputs is NOT called
// on the first execution frame.  Be sure that any dependencies that are set within
// ProcessOutputs are initialized properly in the Init function.
int CCustomDisturbance::ProcessOutputs(void)
{
   int Ret = 0;

   return Ret;
}

// ProcessInputs is the second function called in the frame.  It isn't as time critical
// as ProcessOutputs, but if data needs to be situated before every object has a chance
// to iterate, this is where it is done.
int CCustomDisturbance::ProcessInputs(void)
{
   int Ret = 0;

   return Ret;
}

// Iterate is the last function called in the frame.  This is where the object does any
// computationally intensive work.
int CCustomDisturbance::Iterate(double DeltaTime)
{
   int Ret = 0;
   UNUSED(DeltaTime); // NOTE: You can remove this line when the parameter is used.

   double lat_rd = m_Connection.FSW_Ephemeris_ptr->GetLatitude_rd();
   double lon_rd = m_Connection.FSW_Ephemeris_ptr->GetLongitude_rd();

   m_Tlm.MyTorque_Nm[0] = sin(lat_rd)*0.001;
   m_Tlm.MyTorque_Nm[1] = cos(lon_rd)*0.001;
   m_Tlm.MyTorque_Nm[2] = 0.0;

   if (m_Connection.FSW_AttDetermination_ptr->GetWEst_BDY_rdps().Norm() > 5.0 * C_Pi / 180)
   {
      m_Tlm.MyTorque_Nm = C_VZero;
   }

   return Ret;
}

///////////////////////////////////////////////////////////////////////
// The following functions for implemented interfaces were created by the DevTool.
// Users are responsible for the logic within the function.
///////////////////////////////////////////////////////////////////////
// From interface: CIFODY_Disturbance
const VECTOR CCustomDisturbance::GetLocation_BDY_m(void)
{
   return C_VZero;
}

// From interface: CIFODY_Disturbance
const VECTOR CCustomDisturbance::GetForce_BDY_N(void)
{
   return C_VZero;
}

// From interface: CIFODY_Disturbance
const VECTOR CCustomDisturbance::GetTorque_BDY_Nm(void)
{
   return m_Tlm.MyTorque_Nm;
}

// From interface: CIFMyInterface
const double CCustomDisturbance::GetDataA(void)
{
   return m_Data.DataA;
}

// From interface: CIFMyInterface
const QUATERNION CCustomDisturbance::GetDataB(void)
{
   return m_Data.DataB;
}

// From interface: CIFMyInterface
MyNamespace::EMyEnum CCustomDisturbance::GetMyEnum(void)
{
   return m_Data.MyEnum;
}

// From interface: CIFMyInterface
MyNamespace::MyStruct* CCustomDisturbance::GetMyStruct(void)
{
   return m_Data.MyStruct;
}
